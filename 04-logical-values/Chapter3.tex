\documentclass[xcolor=dvipsnames, xcolor=table]{beamer} % Classe de documento para apresentações
\usepackage{listings}
\usepackage{listings}\usetheme{Berlin}
\usecolortheme{beaver}
\usepackage{textpos}
\usepackage{color}
\usepackage{wasysym}
\renewcommand\tabcolsep{4pt}
\usepackage{csquotes} 
\usepackage{wrapfig}
\usepackage{microtype}
\usepackage[labelfont=bf]{caption}
\usepackage{epigraph}
\usepackage[english]{babel}
\usepackage{float}
\usepackage{hyperref}
\usepackage{amsmath}
\newcommand{\dd}[1]{\mathrm{d}#1}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsbsy}
\usepackage{graphicx}
\usepackage{mathtools}

\usepackage{booktabs}

\usepackage{adjustbox}
\hypersetup{pdfpagemode=FullScreen} % para o pdf abrir automaticamente em modo full screen
\setbeamertemplate{caption}[numbered] % para numerar as tabelas
\usepackage{subcaption}
\usepackage[none]{hyphenat} 
\usepackage{bm} %%% bold vectors
\usepackage{tabularx}  
\usepackage{tikz}




\setbeamercolor{author in head/foot}{fg=Maroon}     % cor do nome do autor no rodape
\setbeamercolor{institute in head/foot}{fg=Maroon}  % cor do nome do ISEG no rodape
\setbeamercolor{frametitle}{fg=Maroon, bg=black!9} % cor da letra e do fundo fa faixa com o nome de cada slide
\setbeamercolor{caption name}{fg=Maroon, bg=black!9}
\setbeamercolor*{title}{fg=white, bg=Maroon}          % cor do titulo e da caixa de titulo na capa
\setbeamercolor{itemize item}{fg=Maroon}               % cor dos bullets do ambiente \itemize 


\makeatletter % criaçao de um ambiente sem TOC no cabeçalho do slide
\newenvironment{noheadline}{
\setbeamertemplate{headline}{}
\addtobeamertemplate{frametitle}{\vspace*{-0.9\baselineskip}}{}
}{}
\makeatother

\usepackage[beamer,customcolors]{hf-tikz}

\tikzset{hl/.style={
    set fill color=red!80!black!40,
    set border color=red!80!black,
  },
}


\title[Non-Numeric Values]{Non-Numeric Values}
\author[Pedro Fonseca]{\textbf {Pedro Fonseca}}
\titlegraphic{\includegraphics[width=1.5cm]{yes}}
\institute[Introduction to R]{\textbf {Introduction to R}}
\date{\today}


% position the yes
\addtobeamertemplate{frametitle}{}{%
\begin{textblock*}{100mm}(.85\textwidth,-.9cm)
\includegraphics[scale=.05]{yes}
\end{textblock*}}



%%%%%%%%%%%%% Ambiente de teorema/definição com as cores do ISEG %%%%%%

\makeatletter
\def\th@mystyle{%
    \normalfont % body font
    \setbeamercolor{block title example}{bg=Maroon,fg=white}
    \setbeamercolor{block body example}{bg=black!9,fg=black}
    \def\inserttheoremblockenv{exampleblock}
  }
\makeatother
\theoremstyle{mystyle}
\newtheorem*{defi}{Definição}

\setbeamertemplate{defis}[numbered]



%%%%%%%%%%%%%%%% Bibliografia %%%%%%%%%%%%%%%%%%%%%%%

\usepackage{url}
\usepackage[style=authoryear, bibencoding=utf8, minnames=1, maxnames=3,
maxbibnames=99,backref=true, natbib=true, dashed=false, terseinits=true, 
firstinits=true, uniquename=false, uniquelist=true, labeldate=true, 
doi=false, isbn=false, natbib=true, backend=biber]{biblatex}
\DefineBibliographyStrings{english}{%
    backrefpage = {Cited on page},
    backrefpages = {Cited on pages},
}
% Change the default formatting to be more "statistical"
\DeclareFieldFormat{url}{\url{#1}}
\DeclareFieldFormat[article]{pages}{#1}
\DeclareFieldFormat[inproceedings]{pages}{\lowercase{pp.}#1}
\DeclareFieldFormat[incollection]{pages}{\lowercase{pp.}#1}
\DeclareFieldFormat[article]{volume}{\mkbibbold{#1}}
\DeclareFieldFormat[article]{number}{\mkbibparens{#1}}
\DeclareFieldFormat[article]{title}{\MakeCapital{#1}}
\DeclareFieldFormat[article]{url}{}
\DeclareFieldFormat[book]{url}{}
\DeclareFieldFormat[inbook]{url}{}
\DeclareFieldFormat[incollection]{url}{}
\DeclareFieldFormat[inproceedings]{url}{}
\DeclareFieldFormat[inproceedings]{title}{#1}
\DeclareFieldFormat{shorthandwidth}{#1}
% No dot before number of articles
\usepackage{xpatch}
\xpatchbibmacro{volume+number+eid}{\setunit*{\adddot}}{}{}{}
% Remove In: for an article.
\renewbibmacro{in:}{%
  \ifentrytype{article}{}{%
  \printtext{\bibstring{in}\intitlepunct}}}
% Get rid of months in citations
\AtEveryBibitem{\clearfield{month}}
\AtEveryCitekey{\clearfield{month}}
\setlength{\parindent}{1,3cm}
\raggedbottom

\renewcommand\bibfont{\scriptsize}
% If you have more than one page of references, you want to tell beamer
% to put the continuation section label from the second slide onwards
\setbeamertemplate{frametitle continuation}[from second]
% Now get rid of all the colours
\setbeamercolor*{bibliography entry title}{fg=black}
\setbeamercolor*{bibliography entry author}{fg=black}
\setbeamercolor*{bibliography entry location}{fg=black}
\setbeamercolor*{bibliography entry note}{fg=black}





\begin{document}
%%%%%%%%%%%%%%%%%%%%%  CAPA  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{noheadline}

\begin{frame}%[plain]
\vfill
\centering

\begin{beamercolorbox}[sep=8pt,center,colsep=-4bp,rounded=true,shadow=true]{title}
\usebeamerfont{title}\inserttitle\par%
\ifx\insertsubtitle\@empty%
\else%
\vskip0.25em%
{\usebeamerfont{subtitle}\usebeamercolor[fg]{subtitle}\insertsubtitle\par}%
\fi%     
\end{beamercolorbox}%

\vskip1em\par

\begin{beamercolorbox}[sep=8pt,center,colsep=-4bp,rounded=true,shadow=true]{author}
\usebeamerfont{author}\insertauthor
\end{beamercolorbox}

{\usebeamercolor[fg]{titlegraphic}\inserttitlegraphic\par}

\begin{beamercolorbox}[sep=8pt,center,colsep=-4bp,rounded=true,shadow=true]{institute}
\usebeamerfont{institute}\insertinstitute
\end{beamercolorbox}

\begin{beamercolorbox}[sep=8pt,center,colsep=-4bp,rounded=true,shadow=true]{date}
\usebeamerfont{date}\insertdate
\end{beamercolorbox}\vskip0.5em

\end{frame}
\end{noheadline}



%%%%%%%%%%%%%% ITEMIZE SHAPES AND COLLERS%%%%%%%%%%%%%%%%%%%%%%%%%

\setbeamertemplate{itemize item}{\color{Maroon}\newmoon}
\setbeamertemplate{itemize subitem}{\color{Maroon}$\blacktriangleright$}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Logical values}  

\subsection{Logical Values and Logical Operations}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Introduction}
\begin{itemize}
\item Statistical programming sometimes requires non-numeric values. 
\item Examples of non numerical values in R: characters and logical values. 
\end{itemize}

\end{frame}



\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{What are logical values?}
\begin{itemize}
\item Logical values can only have two values: TRUE or FALSE.
\item Logical values in R can be abbreviated as T or F.

\begin{verbatim}
> foo <- TRUE
> foo
[1] TRUE

> bar <- F
> bar
[1] FALSE
\end{verbatim}
\end{itemize}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Logical vectors and matrices}

\begin{itemize}

\item A logical vector:

\begin{verbatim}
> baz <- c(TRUE, FALSE, FALSE, FALSE, TRUE, FALSE)
> baz
[1]  TRUE FALSE FALSE FALSE  TRUE FALSE
\end{verbatim}

\item A logical  matrix: 

\begin{verbatim}
> qux <- matrix(data = baz, nrow = 3, ncol = 2)
> qux
      [,1]  [,2]
[1,]  TRUE FALSE
[2,] FALSE  TRUE
[3,] FALSE FALSE
\end{verbatim}

\end{itemize}


\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Basic logical operators}

\begin{figure}[H]
\includegraphics[width=7.5cm]{Screenshot_1}
\caption{Basic logical operators in R}
\end{figure}

\end{frame}



\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Logical comparisons}

\begin{itemize}
\item Logicals can be used to check relationships between values:
\begin{verbatim}
> 1 == 2
[1] FALSE

> 1>2
[1] FALSE

> (2-1) <= 2
[1] TRUE

> 1 != (2+3)
[1] TRUE

\end{verbatim}
\end{itemize}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Logical comparisons}

\begin{itemize}
\item Logicals can be used to check relationships between variables:
\begin{verbatim}

> x <- log(5, base = 10)
> y <- log(5, base = exp(1))

> y == x
[1] FALSE
> y >= x
[1] TRUE

> c(x, y)
[1] 0.698970 1.609438

\end{verbatim}
\end{itemize}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Vectorized logical comparison}


\begin{verbatim}

> vec_x <- c(1, 5, 6, 7, 3)
> vec_y <- c(1, 6, 8, 2, 1)

> vec_x == 5
[1] FALSE  TRUE FALSE FALSE FALSE
> vec_x != 5
[1]  TRUE FALSE  TRUE  TRUE  TRUE
> vec_x >= vec_y
[1]  TRUE FALSE FALSE  TRUE  TRUE

\end{verbatim}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{The ! operator}

\begin{itemize}
\item "!" is the negation (NOT) operator
\begin{verbatim}

> !TRUE
[1] FALSE

> !FALSE
[1] TRUE

> !c(TRUE, FALSE, TRUE, TRUE, FALSE)
[1] FALSE  TRUE FALSE FALSE  TRUE

\end{verbatim}
\end{itemize}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{The ! operator}

\begin{verbatim}

> x <- c(FALSE, TRUE)
> !x
[1]  TRUE FALSE

\end{verbatim}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{The ! operator}


\begin{verbatim}

> vec_x <- c(1, 5, 6, 7, 3)
> vec_y <- c(1, 6, 8, 2, 1)

> vec_x >= vec_y
[1]  TRUE FALSE FALSE  TRUE  TRUE

> !(vec_x >= vec_y)
[1] FALSE  TRUE  TRUE FALSE FALSE

\end{verbatim}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{The ! operator}

\begin{verbatim}

> vec_x <- c(1, 5, 6, 7, 3)
> vec_y <- c(1, 6, 8, 2, 1)

> vec_x == 5
[1] FALSE  TRUE FALSE FALSE FALSE
> !(vec_x == 5)
[1]  TRUE FALSE  TRUE  TRUE  TRUE

> vec_x == vec_y
[1]  TRUE FALSE FALSE FALSE FALSE

\end{verbatim}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{! vs \textit{Factorial}}

\begin{itemize}
\item Do not confuse "!" with the factorial function
\item In R, the factorial function is \textit{factorial}:

\begin{verbatim}
> factorial(5)
[1] 120
> 5 * 4 * 3 * 2 * 1
[1] 120
\end{verbatim}

\item Alternatively, can use the product function:
\begin{verbatim}
> prod(5:1)
[1] 120
> prod(5, 4, 3, 2, 1)
[1] 120

\end{verbatim}
\end{itemize}


\end{frame}

\subsection{Subseting and Overwriting with Logicals}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Subset with logicals}

\begin{verbatim}
> myvec <- c(5, -2.3, 4, 4, 1)

> myvec[c(TRUE, FALSE, TRUE, FALSE, FALSE)]
[1] 5 4
\end{verbatim}

\begin{itemize}
\item Recycling rules apply as usual:

\begin{verbatim}
> myvec[c(TRUE, FALSE)]
[1] 5 4 1
\end{verbatim}
\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Subset with logicals}

\begin{verbatim}
> mymat <- matrix(1:9, nrow = 3)
> mymat
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8
[3,]    3    6    9

> mymat[, c(TRUE, FALSE, TRUE)]
     [,1] [,2]
[1,]    1    7
[2,]    2    8
[3,]    3    9

\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Subset with logicals}

\begin{verbatim}

> mymat[c(TRUE, TRUE, FALSE), ]
     [,1] [,2] [,3]
[1,]    1    4    7
[2,]    2    5    8

> mymat[c(TRUE, TRUE, FALSE), c(TRUE, TRUE, FALSE)]
     [,1] [,2]
[1,]    1    4
[2,]    2    5
\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Subset with logicals}

\begin{verbatim}
> myvec <- c(5, -2.3, 4, 4, -1)
 
> myvec < 0
[1] FALSE  TRUE FALSE FALSE  TRUE
> myvec[myvec < 0]
[1] -2.3 -1.0
 
> myvec != 4
[1]  TRUE  TRUE FALSE FALSE  TRUE
> myvec[myvec != 4]
[1]  5.0 -2.3 -1.0
\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Overwriting with logicals}

\begin{verbatim}
> mymat <- matrix(1:9, nrow = 3, byrow = TRUE)
> mymat
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9

> mymat < 5
      [,1]  [,2]  [,3]
[1,]  TRUE  TRUE  TRUE
[2,]  TRUE FALSE FALSE
[3,] FALSE FALSE FALSE
\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Overwriting with logicals}

\begin{verbatim}
> mymat[mymat < 5]
[1] 1 4 2 3

> mymat[mymat < 5] <- 0
> mymat
     [,1] [,2] [,3]
[1,]    0    0    0
[2,]    0    5    6
[3,]    7    8    9
\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Overwriting with logicals}

\begin{verbatim}
> mymat <- matrix(1:9, nrow = 3, byrow = TRUE)
> mymat
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9

> which(mymat < 5)
[1] 1 2 4 7

> mymat[which(mymat < 5)] <- 0 # same result as the  
>   								   # previous slide
\end{verbatim}

\end{frame}

\subsection{Missing Values}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Introduction}

\begin{itemize}
\item In R, missing values are represented by NA (not available)
\item NAs are exceptional logical values.
\item The \textit{is.logical} testes whether or not values are logic:

\begin{verbatim}
> is.logical(54)
[1] FALSE
> is.logical(myvec)
[1] FALSE
> is.logical(TRUE)
[1] TRUE
> is.logical(FALSE)
[1] TRUE
> is.logical(NA)
[1] TRUE
\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Introduction}

\begin{itemize}
\item In the previous lesson, we dealt with numerical values
\item There is also a test function for numerics:

\begin{verbatim}
> is.numeric(54)
[1] TRUE
> is.numeric(myvec)
[1] TRUE
> is.numeric(TRUE)
[1] FALSE
> is.numeric(FALSE)
[1] FALSE
> is.numeric(NA)
[1] FALSE
\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Operations with NAs}

\begin{itemize}
\item When NAs are present, caution is required!

\begin{verbatim}
> y <- c(1, 2, 3, NA)

> NA + 5
[1] NA
 > (NA + 3) > 0
[1] NA

> sum(1, 5, 6, NA, 7)
[1] NA 
> mean(y)
[1] NA
\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile]

\begin{itemize}
\frametitle{Dealing with missing values}
\item Many functions have a \textit{na.rm} argument. It is set to FALSE by default. 

\begin{verbatim}
> y <- c(1, 2, 3, 7, 0.5, NA)
> y_without_nas <- y[-6]

> mean(y, na.rm = TRUE)
[1] 2.7
> mean(y_without_nas)
[1] 2.7
> sum(1, 5, 6, NA, 7, na.rm = TRUE)
[1] 19
> sum(1, 5, 6, 7)
[1] 19
\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile]

\begin{itemize}
\frametitle{Dealing with missing values}
\item Other option: \textit{na.omit}

\begin{verbatim}
> y <- c(1, 2, 3, 7, 0.5, NA)
> na.omit(y)
[1] 1.0 2.0 3.0 7.0 0.5

> y_new <- na.omit(y)
> y_new
[1] 1.0 2.0 3.0 7.0 0.5
\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile]

\begin{itemize}
\frametitle{Dealing with missing values}
\item  \textit{na.omit} with matrices:

\begin{verbatim}
> (M <- matrix(c(1:3, NA, c(5, 9)), nrow = 3,
 byrow = TRUE))
     [,1] [,2]
[1,]    1    2
[2,]    3   NA
[3,]    5    9
> 
> na.omit(M)
     [,1] [,2]
[1,]    1    2
[2,]    5    9
\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}
\begin{itemize}
\frametitle{Dealing with missing values}
\item  In matrices (and data frames) \textit{na.omit} returns only complete rows!
\item This can be useful in data analysis when only complete cases are to be considered.
\item However, sometimes we have small samples and can't afford to throw away incomplete observations. 
\begin{itemize}
\item Solution: imputation
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Testing for missing values}


\begin{verbatim}
> y <- c(1, 2 , 3, NA)

> is.na(y)
[1] FALSE FALSE FALSE  TRUE

> !is.na(y)
[1]  TRUE  TRUE  TRUE FALSE
\end{verbatim}


\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Testing for missing values}

\begin{verbatim}
> M <- matrix(c(1:3, NA, c(5, 9)), 3, 2, TRUE)
> M
     [,1] [,2]
[1,]    1    2
[2,]    3   NA
[3,]    5    9

> is.na(M)
      [,1]  [,2]
[1,] FALSE FALSE
[2,] FALSE  TRUE
[3,] FALSE FALSE
\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Imputation of missing values}

\begin{verbatim}
> M <- matrix(c(1:3, NA, c(5, NA)), 2, 3, TRUE)
> M
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]   NA    5   NA

> is.na(M)
      [,1]  [,2]  [,3]
[1,] FALSE FALSE FALSE
[2,]  TRUE FALSE  TRUE

\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Imputation of missing values}

\begin{verbatim}
> M[is.na(M)] <- 0
> M

     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    0    5    0
\end{verbatim}

\begin{itemize}
\item Replacing missing values with zeros can result in severe underestimation of the actual values. Sometimes it better to replace NAs with an estimate of its value.
\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Imputation of missing values}

\begin{verbatim} 
> M <- cbind(
   y  = c(3, NA, 7, 1),
   x1 = c(1, 7,  9, 6),
   x2 = c(6, 7,  9, NA)
 )

> M
      y x1 x2
[1,]  3  1  6
[2,] NA  7  7
[3,]  7  9  9
[4,]  1  6 NA
\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Imputation of missing values}

\begin{verbatim} 
> M[, "y"]
[1]  3 NA  7  1

> is.na(M[, "y"])
[1] FALSE  TRUE FALSE FALSE

> M[is.na(M[, "y"]), "y"] <- median(M[, "y"],
 na.rm = TRUE)

> M[is.na(M[, "x2"]), "x2"] <- median(M[, "x2"],
 na.rm = TRUE)

\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frametitle{Imputation of missing values}

\begin{verbatim} 

> M
     y x1 x2
[1,] 3  1  6
[2,] 3  7  7
[3,] 7  9  9
[4,] 1  6  7
\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Counting missing values}

\begin{itemize}
\item The \textit{table} function is useful here:
\begin{verbatim}
> y <- c(1, 2 , 3, NA, 6, NA, 9, NA)

> is.na(y)
[1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE

> table(is.na(y))
FALSE  TRUE 
    5     3 
\end{verbatim}
\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Counting missing values}

\begin{itemize}
\item  \textit{table} also works with matrices:
\begin{verbatim}
> M <- rbind(
   col1 <- c(2, 5, 7),
   col2 <- c(NA, 5, 7),
   col3 <- c(2, 5, NA)
  )

> table(is.na(M))

FALSE  TRUE 
    7     2 
\end{verbatim}
\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Counting missing values}

\begin{itemize}
\item  Alternative: 
\begin{verbatim}
> y <- c(1, 2 , 3, NA, 6, NA, 9, NA)
> sum(is.na(y))
[1] 3

> M <- rbind(
   col1 <- c(2, 5, 7),
   col2 <- c(NA, 5, 7),
   col3 <- c(2, 5, NA)
 )
> sum(is.na(M))
[1] 2
\end{verbatim}
\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Coercion of logical values}

\begin{itemize}
\item  Why does \textit{sum(is.na())} Work? R coerces logical values to numerical values if you use them in a context where numeric values are expected.

\item How?

\begin{verbatim}
> as.numeric(TRUE)
[1] 1
> as.numeric(FALSE)
[1] 0
\end{verbatim}

\item The \textit{as.numeric} function forces the coercion to numeric.

\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Coercion of logical values}

\begin{verbatim}
> y <- c(1, 2 , 3, NA, 6, NA, 9, NA)
> is.na(y)
[1] FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE
> as.numeric(is.na(y))
[1] 0 0 0 1 0 1 0 1
> sum(as.numeric(is.na(y)))
[1] 3
\end{verbatim}
\begin{itemize}

\item The \textit{as.numeric} function here is redundant since R coerces the inputs of \textit{sum} to numerical if possible.
\item The same happens with matrices.
\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Removing NAs with the \textit{which} function}

\begin{verbatim}
> y <- c(1, 2 , 3, NA, 6, NA, 9, NA)
\end{verbatim}

\begin{itemize}

\item How many NAs in y?

\begin{verbatim}
> length(which(is.na(y)))
[1] 3
\end{verbatim}

\item In which positions are the positions with non-NA values of y?

\begin{verbatim}
> which(is.na(y)) 
[1] 4 6 8
\end{verbatim}

\item Subset y to extract non-missing values only:

\begin{verbatim}
> y[which(!is.na(y))] # notice the "!"
[1] 1 2 3 6 9            
\end{verbatim}
\end{itemize}

\end{frame}

\subsection{Logical Comparisons with Multiple Conditions}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Logical comparison with more than one condition}

\begin{figure}[H]
\includegraphics[scale = .6]{Screenshot_2}
\caption{The "and", "or" and "not" operators in R}
\end{figure}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Logical comparison with more than one condition}

\begin{itemize}

\item Examples:

\begin{verbatim}
> (6 < 4) || (3 != 1)
[1] TRUE

> (6 < 4) || (3 == 1)
[1] FALSE

> (6 < 4) && (3 != 1)
[1] FALSE

> (6 > 4) && (3 >= 1)
[1] TRUE

\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Logical comparison with more than one condition}

\begin{itemize}

\item Examples:

\begin{verbatim}
> y <- c(1, 5 ,3, 1, 2, 9)

> (y > 2) & (y < 6)
[1] FALSE  TRUE  TRUE FALSE FALSE FALSE
 
> (y > 2) | (y < 6)
[1] TRUE TRUE TRUE TRUE TRUE TRUE

\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Logical comparison with more than one condition}

\begin{itemize}

\item Examples:

\begin{verbatim}
> y <- c(1, 5 ,3, 1, 2, 9)

> y[(y > 2) & (y < 6)]
[1] 5 3

> y[(y > 2) | (y < 6)]
[1] 1 5 3 1 2 9

\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Logical comparison with more than one condition}

\begin{itemize}

\item You can  chain as many comparisons as you want:

\begin{verbatim}
> y[y > 2]
[1] 5 3 9

> y[(y > 2) | (y < 6)]
[1] 1 5 3 1 2 9

> y[((y > 2) | (y < 6)) & (y != 2)]
[1] 1 5 3 1 9
\end{verbatim}

\item When performing multiple comparisons, parentheses are recommended!

\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{The \textit{any} and \textit{all} functions}

\begin{itemize}
\item Given a set of logical vectors, is at least one of the values true?
\item Given a set of logical vectors, are all of the values true?
\end{itemize}

\begin{verbatim}
> y <- c(1, 5 , 3, NA, 2, 9)

> any(y > 2, y < 6, !is.na(y))
[1] TRUE

> all(y > 2, y < 6, !is.na(y))
[1] FALSE
\end{verbatim}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Exclusive OR}

\begin{itemize}
\item \textit{xor} indicates element-wise exclusive OR
\begin{verbatim}
> y <- c(1, 5 ,3, 1, 2, 9)

> xor(y>2, y<6)
[1]  TRUE FALSE FALSE  TRUE  TRUE  TRUE
\end{verbatim}

\end{itemize}

\end{frame}

\begin{frame}[fragile] %%%%%%%%%%%%%%%%%%%%%%% FRAME %%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frametitle{Logical comparison with more than one condition}

\begin{figure}
\includegraphics[scale=.8]{logical.png}
\caption{A visual perspective of logical operators}
\end{figure}

\end{frame}



\end{document}




